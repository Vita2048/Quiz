<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Czech Cities Quiz — 20 Questions</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#22c1c3;
    --muted:#9aa4b2;
    --glass: rgba(255,255,255,0.03);
  }
  body{
    margin:0;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    background: linear-gradient(180deg,#071024 0%, #071824 100%);
    color:#e6eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
  }
  .wrap{
    width:100%;
    max-width:1200px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;
    box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    overflow:hidden;
    display:grid;
    grid-template-columns: 1fr 420px;
    gap:20px;
    padding:20px;
  }

  @media (max-width:980px){
    .wrap { grid-template-columns: 1fr; padding:12px; }
    .right { order:2; }
    .left { order:1; }
  }

  .left{
    background:var(--glass);
    border-radius:12px;
    padding:14px;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
  }
  .map-holder{
    background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(255,255,255,0.02));
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:420px;
  }
  svg#czMap path {
  stroke: #cccccc !important;
  stroke-width: 0.8 !important;
  fill: #0b1220;
}

.flash-dot {
  animation: flash 1s infinite;
}

@keyframes flash {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

  .right{
    background:var(--card);
    border-radius:12px;
    padding:16px;
    display:flex;
    flex-direction:column;
    gap:14px;
  }

  .progress {
    display:flex;
    align-items:center;
    gap:12px;
    justify-content:space-between;
  }
  .progress .bar {
    flex:1;
    height:12px;
    background:rgba(255,255,255,0.05);
    border-radius:8px;
    overflow:hidden;
    margin-left:12px;
  }
  .progress .bar > i {
    height:100%;
    display:block;
    width:0%;
    background:linear-gradient(90deg, #22c1c3, #3b82f6);
    border-radius:8px;
    transition:width 400ms ease;
  }
  h1{
    margin:0;
    font-size:18px;
    letter-spacing:0.2px;
  }
  .meta{
    color:var(--muted);
    font-size:13px;
  }

  .choices{
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-top:6px;
  }
  .choice{
    background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));
    border-radius:10px;
    padding:10px 12px;
    cursor:pointer;
    display:flex;
    align-items:center;
    gap:10px;
    border:1px solid rgba(255,255,255,0.03);
    transition: transform 120ms ease, box-shadow 120ms ease;
    user-select:none;
  }
  .choice:hover{ transform:translateY(-4px); box-shadow: 0 8px 18px rgba(2,6,23,0.5); }
  .choice.selected{ outline:2px solid rgba(34,193,195,0.18); box-shadow: 0 10px 22px rgba(34,193,195,0.06); }
.choice.correct {
  border: 2px solid #22c55e;
  background: #14532d;
  color: #d1fae5;
}
.choice.wrong {
  border: 2px solid #ef4444;
  background: #7f1d1d;
  color: #fee2e2;
}

  .controls{
    display:flex;
    gap:10px;
    margin-top:8px;
    justify-content:flex-end;
  }
  button.btn{
    background:linear-gradient(180deg,#1f8b8b,#197a7a);
    color:white;
    border:none;
    padding:10px 14px;
    border-radius:10px;
    font-weight:600;
    cursor:pointer;
  }
  button.btn.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--muted);
    font-weight:600;
  }

  .summary{
    padding:12px;
    border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));
    font-size:14px;
  }
  .summary h2{ margin:0 0 6px 0; font-size:16px; }
  .summary .bigscore{
    display:flex;
    gap:18px;
    align-items:center;
    margin-bottom:8px;
  }
  .summary .bigscore .score{
    font-size:28px;
    font-weight:700;
    color:#dbeefe;
  }
  .breakdown{
    margin-top:12px;
    overflow:auto;
    max-height:380px;
    border-radius:8px;
  }
  table{
    width:100%;
    border-collapse:collapse;
    font-size:13px;
  }
  th,td{
    padding:8px 6px;
    text-align:left;
    border-bottom:1px dashed rgba(255,255,255,0.04);
  }
  th{ color:var(--muted); font-weight:600; font-size:12px; }
  tr.correct td{ background: rgba(34,193,195,0.02); }
  tr.wrong td{ background: rgba(255,80,80,0.02); }

  .footer{
    font-size:12px;
    color:var(--muted);
    text-align:center;
    margin-top:10px;
  }

  .center { display:flex; align-items:center; justify-content:center; }
  .hint { color:var(--muted); font-size:13px; }
</style>
</head>
<body>
<div id="difficultyScreen" style="text-align:center;max-width:500px;margin:auto;">
  <h1>Czech Cities Quiz</h1>
  <p>Select difficulty level (1 = easiest, 4 = hardest)</p>
  <div style="display:flex;gap:10px;justify-content:center;margin-top:20px;">
    <button class="btn" onclick="startQuiz(1)">Level 1</button>
    <button class="btn" onclick="startQuiz(2)">Level 2</button>
    <button class="btn" onclick="startQuiz(3)">Level 3</button>
    <button class="btn" onclick="startQuiz(4)">Level 4</button>
  </div>
</div>

<div class="wrap" id="quizWrap" style="display:none" role="application" aria-label="Czech Cities Quiz">
  <div class="left">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <div>
        <h1>Czech Cities Quiz</h1>
        <div class="meta">Find the city shown by the flashing dot. 20 random cities per session.</div>
      </div>
      <div id="top-actions" style="text-align:right">
        <div class="meta" id="progressText">Question 0/20</div>
        <div style="height:6px"></div>
        <div class="progress" style="width:260px;">
          <div style="font-size:12px;color:var(--muted);width:110px">Progress</div>
          <div class="bar" aria-hidden="true"><i id="progressBar"></i></div>
        </div>
      </div>
    </div>

    <div class="map-holder" aria-hidden="false">
      <div id="mapContainer" style="width:100%;max-width:900px;">
        <div id="mapLoader" class="center" style="padding:34px;">
          <div style="text-align:center">
            <div class="hint">Loading map and cities...</div>
            <div style="margin-top:10px"><small class="meta">If nothing loads, check CORS or network access to the two files.</small></div>
          </div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
      <div class="hint">Tip: distractors are chosen from nearby cities for a plausible challenge.</div>
      <div id="controlsSmall"></div>
    </div>
  </div>

  <div class="right">
    <div>
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div>
          <div style="font-size:13px;color:var(--muted)">Question</div>
          <div style="font-size:18px;font-weight:700" id="questionTitle">—</div>
        </div>
        <div style="display:flex;align-items:center;gap:20px;">
          <div>
            <div class="meta">Level</div>
            <div style="font-size:16px;font-weight:600" id="levelLabel">—</div>
          </div>
          <div style="text-align:right">
            <div class="meta">Score</div>
            <div style="font-size:18px;font-weight:700" id="scoreDisplay">0</div>
          </div>
        </div>

      </div>

      <div class="choices" id="choices"></div>

      <div class="controls">
        <button class="btn secondary" id="btnRestart">Restart</button>
        <button class="btn" id="btnNext" disabled>Next</button>
      </div>
    </div>

    <div class="summary" id="summaryPanel" style="display:none;">
      <h2>Quiz summary</h2>
      <div class="bigscore">
        <div class="score" id="finalScore">0 / 20</div>
        <div>
          <div class="meta">Percentage</div>
          <div style="font-size:20px;font-weight:700" id="finalPct">0%</div>
        </div>
      </div>

      <div class="breakdown" id="breakdown"></div>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
        <button class="btn secondary" id="btnExport">Export CSV</button>
        <button class="btn" id="btnPlayAgain">Play Again</button>
      </div>
    </div>

  </div>
</div>

<script>
/*
  Complete quiz script with CSV (City name,population,lat,lng), population filters per difficulty,
  and a robust annotation placement system to avoid label/dot/line overlaps and crossings.
*/

const SVG_URL = 'https://vita2048.github.io/Quiz/cz.svg';
const CSV_URL = 'https://vita2048.github.io/Quiz/geoname_czech_cities.csv';
const TOTAL_QUESTIONS = 20;
const CZECH_BBOX = { minLat:48.55, maxLat:51.06, minLon:12.09, maxLon:18.87 };
let difficulty = 1;

function startQuiz(level) {
  difficulty = level;
  document.getElementById('levelLabel').textContent = "Level " + level;
  document.getElementById('difficultyScreen').style.display = 'none';
  document.getElementById('quizWrap').style.display = 'grid';
  init();
}

function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; }

function parseCSVsmart(txt){
  const lines = txt.trim().split(/\r?\n/).filter(Boolean);
  if(!lines.length) return [];
  const delim = (lines[0].includes(';') && !lines[0].includes(',')) ? ';' : ',';
  const headers = lines[0].split(delim).map(h=>h.trim());
  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols = lines[i].split(delim).map(c=>c.trim());
    const o={};
    for(let j=0;j<headers.length;j++) o[headers[j]]=cols[j]||'';
    rows.push(o);
  }
  return rows;
}

function hav(a,b){
  const R=6371, dLat=(b.lat-a.lat)*Math.PI/180, dLon=(b.lon-a.lon)*Math.PI/180;
  const la=a.lat*Math.PI/180, lb=b.lat*Math.PI/180;
  const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2);
  const A=s1*s1+Math.cos(la)*Math.cos(lb)*s2*s2;
  return 2*R*Math.atan2(Math.sqrt(A),Math.sqrt(1-A));
}

/* --- state and DOM refs --- */
let cities=[], citiesFiltered=[], quizCities=[], currentIndex=0, score=0, answers=[], svgElement=null, svgViewBox={x:0,y:0,width:800,height:600};
const mapContainer=document.getElementById('mapContainer'),
      mapLoader=document.getElementById('mapLoader'),
      progressText=document.getElementById('progressText'),
      progressBar=document.getElementById('progressBar'),
      questionTitle=document.getElementById('questionTitle'),
      choicesDiv=document.getElementById('choices'),
      scoreDisplay=document.getElementById('scoreDisplay'),
      btnNext=document.getElementById('btnNext'),
      btnRestart=document.getElementById('btnRestart'),
      summaryPanel=document.getElementById('summaryPanel'),
      finalScore=document.getElementById('finalScore'),
      finalPct=document.getElementById('finalPct'),
      breakdown=document.getElementById('breakdown'),
      btnPlayAgain=document.getElementById('btnPlayAgain'),
      btnExport=document.getElementById('btnExport');

/* --- init / load --- */
async function init(){
  try{
    clearAllStateBeforeInit();
    const [csvRes,svgRes]=await Promise.all([fetch(CSV_URL),fetch(SVG_URL)]);
    const csvTxt=await csvRes.text(), svgTxt=await svgRes.text();
    const parsed=parseCSVsmart(csvTxt);

    cities = parsed.map(r=>{
      const name = r['City name'] || r['City'] || r['city'] || r['Name'] || r['name'] || r['Město'] || '';
      const popRaw = r['population'] || r['Population'] || r['pop'] || '';
      const latRaw = r['lat'] || r['latitude'] || r['Lat'] || '';
      const lonRaw = r['lng'] || r['lon'] || r['longitude'] || r['Lon'] || '';
      const population = parseInt(String(popRaw||'').replace(/\s+/g,'').replace(/,/g,''),10);
      const lat = parseFloat(String(latRaw||'').replace(',', '.'));
      const lon = parseFloat(String(lonRaw||'').replace(',', '.'));
      return { name: name||'', population: isFinite(population)?population:NaN, lat: isFinite(lat)?lat:NaN, lon: isFinite(lon)?lon:NaN };
    }).filter(c => c.name && isFinite(c.lat) && isFinite(c.lon));

    if(!cities.length) throw new Error('No valid cities parsed from CSV.');

    mapContainer.innerHTML = svgTxt;
    svgElement = mapContainer.querySelector('svg');
    if(!svgElement) throw new Error('SVG missing root <svg>.');
    const vb = svgElement.getAttribute('viewBox');
    if(vb){
      const p=vb.split(/\s+|,/).map(Number).filter(n=>!isNaN(n));
      if(p.length===4) svgViewBox={x:p[0],y:p[1],width:p[2],height:p[3]};
    } else svgElement.setAttribute('viewBox','0 0 800 600');
    svgElement.setAttribute('id','czMap');
    svgElement.querySelectorAll('path').forEach(p=>{ p.setAttribute('stroke','#cccccc'); p.setAttribute('stroke-width','0.8'); });

    applyPopulationFilter();
    if(citiesFiltered.length < 4) throw new Error('Not enough cities after applying population filter for this difficulty level.');

    shuffle(citiesFiltered);
    quizCities = citiesFiltered.slice(0, Math.min(TOTAL_QUESTIONS, citiesFiltered.length));
    answers = quizCities.map(c=>({city:c,correct:c.name,chosen:null,options:[]}));

    mapLoader.style.display='none';
    currentIndex=0; score=0; scoreDisplay.textContent=score;
    updateProgress(); renderQuestion();
  }catch(e){
    mapLoader.innerHTML=`<div style="color:#f99">${e.message}</div>`;
    console.error(e);
  }
}

function clearAllStateBeforeInit(){
  summaryPanel.style.display='none';
  finalScore.textContent='0 / 20';
  finalPct.textContent='0%';
  breakdown.innerHTML='';
  cities = []; citiesFiltered = []; quizCities = []; answers = [];
  currentIndex = 0; score = 0;
  const prevSvg = mapContainer.querySelector('svg');
  if(prevSvg){
    const dot = prevSvg.querySelector('#dotGroup'); if(dot) dot.remove();
    const extra = prevSvg.querySelector('#extraGroup'); if(extra) extra.remove();
  }
  progressText.textContent='Question 0/20';
  progressBar.style.width='0%';
  choicesDiv.innerHTML='';
  scoreDisplay.textContent='0';
  mapLoader.style.display='block';
  mapLoader.innerHTML = `<div style="text-align:center"><div class="hint">Loading map and cities...</div><div style="margin-top:10px"><small class="meta">If nothing loads, check CORS or network access to the two files.</small></div></div>`;
}

/* --- population filtering by difficulty --- */
function applyPopulationFilter(){
  let minPop = 0;
  if (difficulty === 1) minPop = 10000;
  else if (difficulty === 2) minPop = 7000;
  else if (difficulty === 3) minPop = 5000;
  else minPop = 0;

  citiesFiltered = cities.filter(c => isFinite(c.population) && c.population >= minPop);
  if (citiesFiltered.length < 4 && minPop === 0) citiesFiltered = cities.slice();
}

/* --- progress / map helpers --- */
function updateProgress(){
  progressText.textContent=`Question ${Math.min(currentIndex+1,TOTAL_QUESTIONS)}/${TOTAL_QUESTIONS}`;
  progressBar.style.width=Math.round((currentIndex/TOTAL_QUESTIONS)*100)+'%';
  questionTitle.textContent='Which city is this?';
}

function mapLatLonToSvg(lat, lon){
  const { minLat, maxLat, minLon, maxLon } = CZECH_BBOX;
  const { x, y, width, height } = svgViewBox;
  let fx = (lon - minLon) / (maxLon - minLon);
  let fy = (lat - minLat) / (maxLat - minLat);
  let cx = x + Math.min(Math.max(fx, 0), 1) * width;
  let cy = y + (1 - Math.min(Math.max(fy, 0), 1)) * height;
  const path = svgElement?.querySelector('path');
  if (path) {
    const bb = path.getBBox();
    const pad = 5;
    cx = Math.min(Math.max(cx, bb.x + pad), bb.x + bb.width - pad);
    cy = Math.min(Math.max(cy, bb.y + pad), bb.y + bb.height - pad);
  }
  return { x: cx, y: cy };
}

/* --- dot rendering --- */
function renderDotForCity(city){
  if(!svgElement) return;
  const ns='http://www.w3.org/2000/svg';
  let g=svgElement.querySelector('#dotGroup');
  if(!g){ g=document.createElementNS(ns,'g');g.id='dotGroup';svgElement.appendChild(g);}
  while(g.firstChild) g.removeChild(g.firstChild);
  const p=mapLatLonToSvg(city.lat,city.lon);
  const c=document.createElementNS(ns,'circle');
  c.setAttribute('cx',p.x); c.setAttribute('cy',p.y);
  c.setAttribute('r',8); c.setAttribute('fill','red');
  c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width','1.5');
  c.setAttribute('class','flash-dot'); g.appendChild(c);
}

/* --- options building --- */
function buildOptionsForIndex(i){
  const main = quizCities[i];
  let withDist = citiesFiltered.filter(c => c.name !== main.name)
    .map(o => ({ name:o.name, d: hav({lat:main.lat, lon:main.lon}, {lat:o.lat, lon:o.lon}) }));
  let pool;
  if (difficulty === 1) pool = withDist.filter(o => o.d >= 80);
  else if (difficulty === 2) pool = withDist.filter(o => o.d >= 60 && o.d < 80);
  else if (difficulty === 3) pool = withDist.filter(o => o.d >= 35 && o.d < 60);
  else pool = withDist.filter(o => o.d < 35);
  if (pool.length < 3) pool = withDist.sort((a,b)=>a.d-b.d);
  const others = shuffle(pool).slice(0,3).map(o=>o.name);
  const opts = shuffle([main.name, ...others]);
  answers[i].options = opts;
  return opts;
}

/* --- START: GEOMETRY AND ANNOTATION PLACEMENT LOGIC --- */

// --- Robust Geometry Helpers ---
function distSq(p1, p2) { const dx = p1.x-p2.x, dy = p1.y-p2.y; return dx*dx+dy*dy; }
function lineSegmentIntersects(p1, q1, p2, q2) {
    function orientation(p, q, r) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (Math.abs(val) < 1e-9) return 0;
        return (val > 0) ? 1 : 2;
    }
    function onSegment(p, q, r) {
        return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y));
    }
    const o1 = orientation(p1, q1, p2), o2 = orientation(p1, q1, q2),
          o3 = orientation(p2, q2, p1), o4 = orientation(p2, q2, q1);
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p1, p2, q1)) return true;
    if (o2 === 0 && onSegment(p1, q2, q1)) return true;
    if (o3 === 0 && onSegment(p2, p1, q2)) return true;
    if (o4 === 0 && onSegment(p2, q1, q2)) return true;
    return false;
}
function rectIntersectsRect(r1, r2) {
    return !(r2.x >= r1.x + r1.w || r2.x + r2.w <= r1.x || r2.y >= r1.y + r1.h || r2.y + r2.h <= r1.y);
}
function lineIntersectsRect(p1, p2, r) {
    return lineSegmentIntersects(p1, p2, {x:r.x, y:r.y}, {x:r.x+r.w, y:r.y}) ||
           lineSegmentIntersects(p1, p2, {x:r.x+r.w, y:r.y}, {x:r.x+r.w, y:r.y+r.h}) ||
           lineSegmentIntersects(p1, p2, {x:r.x+r.w, y:r.y+r.h}, {x:r.x, y:r.y+r.h}) ||
           lineSegmentIntersects(p1, p2, {x:r.x, y:r.y+r.h}, {x:r.x, y:r.y});
}
function lineIntersectsCircle(p1, p2, c) {
    const l2 = distSq(p1, p2);
    if (l2 === 0) return distSq(p1, c) <= c.r*c.r;
    let t = Math.max(0, Math.min(1, ((c.x - p1.x) * (p2.x - p1.x) + (c.y - p1.y) * (p2.y - p1.y)) / l2));
    const closest = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    return distSq(closest, c) <= c.r * c.r;
}
function rectIntersectsCircle(r, c) {
    const testX = Math.max(r.x, Math.min(c.x, r.x + r.w));
    const testY = Math.max(r.y, Math.min(c.y, r.y + r.h));
    return distSq({x:testX, y:testY}, c) <= c.r * c.r;
}

// --- Improved Annotation Placement ---
function clearExtraAnnotations(){ if(!svgElement) return; const g=svgElement.querySelector('#extraGroup'); if(g) g.innerHTML=''; }

function renderExtraDotsAndLabels(mainCity, options, correctName){
  if (!svgElement) return;
  const ns = 'http://www.w3.org/2000/svg';
  let g = svgElement.querySelector('#extraGroup');
  if (!g) { g = document.createElementNS(ns, 'g'); g.id = 'extraGroup'; svgElement.appendChild(g); }
  g.innerHTML = '';

  const showCities = options.map(name => citiesFiltered.find(c => c.name === name)).filter(Boolean);
  if(!showCities.length) return;

  const mapBbox = svgElement.getBBox();
  const pad = 8, fontSize = 12, labelPadX = 5, labelPadY = 3, approxCharW = 6.5;

  const occupied = { rects: [], circles: [], lines: [] };
  
  const cityData = showCities.map(city => ({
      city, p: mapLatLonToSvg(city.lat, city.lon),
      isCorrect: city.name === correctName,
      dotRadius: city.name === correctName ? 8 : 5
  }));

  for (const data of cityData) {
      occupied.circles.push({ x: data.p.x, y: data.p.y, r: data.dotRadius + 8, isMain: false });
  }
  
  for(const data of cityData) {
    const { city, p, isCorrect, dotRadius } = data;
    let candidates = [];
    const angles = Array.from({length: 12}, (_, i) => i * (Math.PI / 6));
    const radii = [25, 40, 60, 85, 115];

    for (const r of radii) {
      for (const a of angles) {
        const textW = Math.max(30, city.name.length * approxCharW);
        const labelW = textW + labelPadX * 2;
        const labelH = fontSize + labelPadY * 2;
        
        const candidateX = p.x + Math.cos(a) * r;
        const candidateY = p.y + Math.sin(a) * r;

        let lx, ly;
        // ***FIX***: Smartly anchor the label box based on the angle
        if (Math.abs(Math.cos(a)) > Math.abs(Math.sin(a))) { // More horizontal
            lx = (Math.cos(a) > 0) ? candidateX : candidateX - labelW;
            ly = candidateY - labelH / 2;
        } else { // More vertical
            lx = candidateX - labelW / 2;
            ly = (Math.sin(a) > 0) ? candidateY : candidateY - labelH;
        }

        lx = Math.max(mapBbox.x + pad, Math.min(lx, mapBbox.x + mapBbox.width - labelW - pad));
        ly = Math.max(mapBbox.y + pad, Math.min(ly, mapBbox.y + mapBbox.height - labelH - pad));

        const rect = { x: lx, y: ly, w: labelW, h: labelH };
        
        // Find closest connection point on the final rectangle
        const points = [
            {x: rect.x, y: rect.y + rect.h / 2}, {x: rect.x + rect.w, y: rect.y + rect.h / 2},
            {x: rect.x + rect.w / 2, y: rect.y}, {x: rect.x + rect.w / 2, y: rect.y + rect.h}
        ];
        let lineEnd = points[0];
        let min_d = distSq(p, lineEnd);
        for(let i = 1; i < points.length; i++) {
            const d = distSq(p, points[i]);
            if (d < min_d) { min_d = d; lineEnd = points[i]; }
        }

        const line = { p1: p, p2: lineEnd };
        let penalty = Math.sqrt(distSq(line.p1, line.p2)) * 0.1;

        for(const ob of occupied.rects) if(rectIntersectsRect(rect, ob)) penalty += 1000;
        for(const ob of occupied.circles) if(rectIntersectsCircle(rect, ob)) penalty += 1000;
        for(const ob of occupied.lines) if(lineSegmentIntersects(line.p1, line.p2, ob.p1, ob.p2)) penalty += 500;
        for(const ob of occupied.rects) if(lineIntersectsRect(line.p1, line.p2, ob)) penalty += 500;
        for(const ob of occupied.circles) if(lineIntersectsCircle(line.p1, line.p2, ob)) penalty += 500;

        candidates.push({ rect, line, penalty });
      }
    }

    candidates.sort((a, b) => a.penalty - b.penalty);
    const best = candidates[0];

    occupied.rects.push(best.rect);
    occupied.lines.push(best.line);
    
    const lineEl = document.createElementNS(ns,'line');
    lineEl.setAttribute('x1', best.line.p1.x); lineEl.setAttribute('y1', best.line.p1.y);
    lineEl.setAttribute('x2', best.line.p2.x); lineEl.setAttribute('y2', best.line.p2.y);
    lineEl.setAttribute('stroke', '#9aa4b2'); lineEl.setAttribute('stroke-width', '1');
    g.appendChild(lineEl);
    
    const textEl = document.createElementNS(ns,'text');
    textEl.setAttribute('x', best.rect.x + labelPadX);
    textEl.setAttribute('y', best.rect.y + fontSize + (labelPadY/2));
    textEl.setAttribute('fill', '#e6eef6');
    textEl.setAttribute('font-size', fontSize);
    textEl.setAttribute('font-family', 'Inter, sans-serif');
    textEl.setAttribute('font-weight', isCorrect ? '600' : '400');
    textEl.textContent = city.name;
    g.appendChild(textEl);
  }

  for (const data of cityData) {
    const { p, isCorrect, dotRadius } = data;
    const dot = document.createElementNS(ns, 'circle');
    dot.setAttribute('cx', p.x); dot.setAttribute('cy', p.y);
    dot.setAttribute('r', dotRadius); dot.setAttribute('fill', isCorrect ? '#22c55e' : '#ef4444');
    dot.setAttribute('stroke', '#fff'); dot.setAttribute('stroke-width', '1.5');
    g.appendChild(dot);
  }
}
/* --- END: GEOMETRY AND ANNOTATION PLACEMENT LOGIC --- */

/* --- selection and UI --- */
function renderQuestion(){
  clearExtraAnnotations();
  const dotGroup = svgElement.querySelector('#dotGroup');
  if(dotGroup) dotGroup.style.display = 'block';
  if(currentIndex>=quizCities.length){ finishQuiz(); return; }
  btnNext.disabled=true; choicesDiv.innerHTML='';
  const c=quizCities[currentIndex]; renderDotForCity(c);
  const opts=buildOptionsForIndex(currentIndex);
  opts.forEach(o=>{
    const d=document.createElement('div');
    d.className='choice'; d.textContent=o; d.tabIndex=0;
    d.onclick=()=>selectChoice(d); d.onkeypress=(e)=>{if(e.key==='Enter')selectChoice(d)};
    choicesDiv.appendChild(d);
  });
  scoreDisplay.textContent=score;
}

function selectChoice(el){
  document.querySelectorAll('.choice').forEach(c=>c.classList.remove('selected'));
  el.classList.add('selected');
  btnNext.disabled=false;
  const chosen = el.textContent;
  const correct = answers[currentIndex].correct;
  answers[currentIndex].chosen = chosen;

  document.querySelectorAll('.choice').forEach(c=>{
    c.style.pointerEvents='none';
    if(c.textContent===correct) c.classList.add('correct');
    if(c.textContent===chosen && chosen!==correct) c.classList.add('wrong');
  });
  
  const dotGroup = svgElement.querySelector('#dotGroup');
  
  if(chosen===correct) {
    score++;
    const dot = dotGroup?.querySelector('circle');
    if(dot) {
      dot.setAttribute('fill', '#22c55e');
      dot.classList.remove('flash-dot');
    }
  } else {
    // ***FIX***: Only show detailed annotations on wrong answers
    if (dotGroup) dotGroup.style.display = 'none';
    renderExtraDotsAndLabels(quizCities[currentIndex], answers[currentIndex].options, correct);
  }
  
  scoreDisplay.textContent=score;
  if(currentIndex === quizCities.length - 1) finishQuiz();
}

btnNext.onclick=()=>{
  currentIndex++;
  renderQuestion();
  updateProgress();
};

function resetUIAndStateForRestart(){
  summaryPanel.style.display='none';
  breakdown.innerHTML='';
  finalScore.textContent='0 / 20';
  finalPct.textContent='0%';
  if(svgElement){
    const dg = svgElement.querySelector('#dotGroup'); if(dg) dg.remove();
    const eg = svgElement.querySelector('#extraGroup'); if(eg) eg.remove();
  }
  quizCities = []; answers = [];
  currentIndex = 0; score = 0;
  scoreDisplay.textContent='0';
  choicesDiv.innerHTML='';
  progressText.textContent='Question 0/20';
  progressBar.style.width='0%';
  btnNext.disabled = true;
  document.querySelectorAll('.choice').forEach(c => c.style.pointerEvents = 'auto');
}

btnRestart.onclick = () => {
  resetUIAndStateForRestart();
  document.getElementById('quizWrap').style.display = 'none';
  document.getElementById('difficultyScreen').style.display = 'block';
};

btnPlayAgain.onclick = btnRestart.onclick;

function finishQuiz(){
  btnNext.disabled = true;
  summaryPanel.style.display='block';
  finalScore.textContent=`${score}/${TOTAL_QUESTIONS}`;
  finalPct.textContent=Math.round(score/TOTAL_QUESTIONS*100)+'%';
  const rows=answers.map((a,i)=>`
    <tr class="${a.chosen===a.correct?'correct':'wrong'}">
      <td>${i+1}</td><td>${a.city.name}</td>
      <td>${a.chosen||'<i>No answer</i>'}</td><td>${a.correct}</td>
      <td>${a.chosen===a.correct?'✅':'❌'}</td></tr>`).join('');
  breakdown.innerHTML=`<table><thead><tr><th>#</th><th>City</th><th>Your Answer</th><th>Correct</th><th></th></tr></thead><tbody>${rows}</tbody></table>`;
}

btnExport.onclick=()=>{
  const h=['Question','City','Your Answer','Correct Answer','Result'];
  const r=answers.map((a,i)=>[i+1,`"${a.city.name}"`,`"${a.chosen||''}"`,`"${a.correct}"`,a.chosen===a.correct?'Correct':'Wrong']);
  const csv=[h.join(','),...r.map(x=>x.join(','))].join('\n');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='quiz_results.csv'; a.click(); URL.revokeObjectURL(url);
};

</script>

</body>
</html>
