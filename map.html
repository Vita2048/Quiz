<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Czech Cities Population Map</title>
<style>
  :root {
    /* Single source of truth for map outline & leader line color */
    --outline-color: #ffffff;
  }

  html, body {
    margin:0; padding:0;
    height:100%; width:100%;
    background:#071024; color:#fff;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }

  .wrap { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background: linear-gradient(180deg,#071024 0%, #071824 100%); }
  .map-holder { position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  #mapContainer { width:100%; height:100%; }
  #mapContainer svg { width:100%; height:100%; display:block; }

  /* Map outline strokes follow CSS variable; fill set via JS to match background */
  svg#czMap path { stroke: var(--outline-color); stroke-width:0.8; }

  text.city-label {
    fill: var(--outline-color);
    font-size:4px; font-family:sans-serif; text-anchor:middle;
    paint-order: stroke;
    /* Stroke toggled via JS (removed on light backgrounds) */
    stroke-width: 1px;
    pointer-events:none;
    text-rendering: optimizeSpeed; /* crisper at small sizes */
  }

  /* Leader lines use the same outline color */
  .leader { stroke: var(--outline-color); stroke-width: 0.6; stroke-linecap: round; fill: none; opacity:0.9; }

  /* Population filter — unchanged */
  .filter-overlay {
    position:absolute; top:14px; left:14px; background:#0b1220; border:1px solid rgba(255,255,255,0.08);
    border-radius:10px; padding:12px 14px; display:flex; flex-direction:column; gap:10px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.5); z-index:100; min-width:260px;
  }
  .filter-header { display:flex; align-items:center; justify-content:space-between; font-size:13px; color:#9aa4b2; }
  .filter-values { display:flex; align-items:center; justify-content:space-between; font-size:13px; font-weight:600; }

  .range { position:relative; height:32px; }
  .range-track { position:absolute; top:50%; transform:translateY(-50%); left:0; right:0; height:8px;
    background:rgba(255,255,255,0.12); border-radius:8px; }
  .range-fill { position:absolute; top:50%; transform:translateY(-50%); height:8px;
    background:linear-gradient(90deg, #22c1c3, #3b82f6); border-radius:8px; }
  .range-ticks { position:absolute; left:0; right:0; top:100%; display:flex; justify-content:space-between;
    padding-top:6px; font-size:11px; color:#9aa4b2; }
  .handle { position:absolute; top:50%; transform:translate(-50%, -50%); width:14px; height:14px; border-radius:50%;
    background:#fff; border:2px solid #22c1c3; cursor:grab; box-shadow:0 2px 6px rgba(0,0,0,0.4); touch-action:none; }
  .handle:active { cursor:grabbing; }
  .sr { position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(0 0 0 0); }
  #mapLoader { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#9aa4b2; text-align:center; padding:10px; }

  /* Background color panel (right) */
  .bg-panel {
    position:absolute; top:14px; right:14px; background:#0b1220; border:1px solid rgba(255,255,255,0.08);
    border-radius:10px; padding:12px 14px; display:flex; flex-direction:column; gap:10px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.5); z-index:100; min-width:220px;
  }
  .bg-title { font-size:13px; color:#9aa4b2; }
  .bg-row { display:flex; align-items:center; gap:10px; }
  .color-options { display:flex; gap:8px; flex-wrap:wrap; }
  .color-btn { width:24px; height:24px; border-radius:50%; border:2px solid #fff; cursor:pointer; }
  .color-input { flex:1; }
</style>
</head>
<body>
<div class="wrap">
  <div class="map-holder">
    <!-- Population filter (unchanged) -->
    <div class="filter-overlay" role="group" aria-label="Population filter">
      <div class="filter-header">
        <div>Population filter</div>
      </div>
      <div class="filter-values">
        <div>Min: <span id="minVal">3,000</span></div>
        <div>Max: <span id="maxVal">2,000,000</span></div>
      </div>
      <div class="range" id="range">
        <div class="range-track"></div>
        <div class="range-fill" id="rangeFill" style="left:0%; width:100%;"></div>
        <div class="handle" id="handleMin" aria-label="Minimum population" role="slider" aria-valuemin="3000" aria-valuemax="2000000" aria-valuenow="3000"></div>
        <div class="handle" id="handleMax" aria-label="Maximum population" role="slider" aria-valuemin="3000" aria-valuemax="2000000" aria-valuenow="2000000"></div>
        <div class="range-ticks" id="ticks"></div>
        <div class="sr" id="rangeSr" aria-live="polite"></div>
      </div>
    </div>

    <!-- Background color panel -->
    <div class="bg-panel" role="group" aria-label="Background color">
      <div class="bg-title">Background color</div>
      <div class="bg-row">
        <input type="color" id="bgColorPicker" class="color-input" value="#071024" aria-label="Pick background color" />
      </div>
      <div class="color-options" aria-label="Preset colors">
        <div class="color-btn" style="background:#071024" data-color="#071024" title="#071024"></div>
        <div class="color-btn" style="background:#071824" data-color="#071824" title="#071824"></div>
        <div class="color-btn" style="background:#0b1220" data-color="#0b1220" title="#0b1220"></div>
        <div class="color-btn" style="background:#1e293b" data-color="#1e293b" title="#1e293b"></div>
        <div class="color-btn" style="background:#111827" data-color="#111827" title="#111827"></div>
        <div class="color-btn" style="background:#ffffff" data-color="#ffffff" title="#ffffff"></div>
        <div class="color-btn" style="background:#f59e0b" data-color="#f59e0b" title="#f59e0b"></div>
        <div class="color-btn" style="background:#3b82f6" data-color="#3b82f6" title="#3b82f6"></div>
      </div>
    </div>

    <div id="mapContainer">
      <div id="mapLoader">Loading map and cities…</div>
    </div>
  </div>
</div>

<script>
const SVG_URL = 'https://vita2048.github.io/Quiz/cz.svg';
const CSV_URL = 'https://vita2048.github.io/Quiz/geoname_czech_cities.csv';
const CZECH_BBOX = { minLat:48.55, maxLat:51.06, minLon:12.09, maxLon:18.87 };
const STEPS = [3000, 5000, 10000, 15000, 20000, 30000, 50000, 100000, 1000000, 2000000];

let cities = [];
let svgElement = null;
let svgViewBox = { x:0, y:0, width:800, height:600 };

let minIndex = 1;
let maxIndex = STEPS.length - 1;
const rangeEl = document.getElementById('range');
const handleMin = document.getElementById('handleMin');
const handleMax = document.getElementById('handleMax');
const rangeFill = document.getElementById('rangeFill');
const ticksEl = document.getElementById('ticks');
const minValEl = document.getElementById('minVal');
const maxValEl = document.getElementById('maxVal');
const srEl = document.getElementById('rangeSr');

function fmt(n){ return n.toLocaleString(); }
function stepToPercent(i){ return (i/(STEPS.length-1))*100; }

function mapLatLonToSvg(lat, lon) {
  const { minLat, maxLat, minLon, maxLon } = CZECH_BBOX;
  const { x, y, width, height } = svgViewBox;
  let fx = (lon - minLon) / (maxLon - minLon);
  let fy = (lat - minLat) / (maxLat - minLat);
  let cx = x + Math.min(Math.max(fx, 0), 1) * width;
  let cy = y + (1 - Math.min(Math.max(fy, 0), 1)) * height;
  return { x: cx, y: cy };
}

function renderTicks(){
  ticksEl.innerHTML = '';
  STEPS.forEach((v,i)=>{
    const tick = document.createElement('div');
    tick.style.flex = '1 1 auto';
    tick.style.textAlign = i===0 ? 'left' : (i===STEPS.length-1 ? 'right' : 'center');
    tick.textContent = v >= 1000000 ? (v/1000000)+'M' : (v >= 1000 ? (v/1000)+'k' : v);
    ticksEl.appendChild(tick);
  });
}
renderTicks();

function updateSliderUI(){
  const pctMin = stepToPercent(minIndex);
  const pctMax = stepToPercent(maxIndex);
  handleMin.style.left = pctMin + '%';
  handleMax.style.left = pctMax + '%';
  const left = Math.min(pctMin, pctMax);
  const width = Math.abs(pctMax - pctMin);
  rangeFill.style.left = left + '%';
  rangeFill.style.width = width + '%';
  const minPop = STEPS[Math.min(minIndex, maxIndex)];
  const maxPop = STEPS[Math.max(minIndex, maxIndex)];
  minValEl.textContent = fmt(minPop);
  maxValEl.textContent = fmt(maxPop);
  handleMin.setAttribute('aria-valuenow', String(minPop));
  handleMax.setAttribute('aria-valuenow', String(maxPop));
  srEl.textContent = `Population range ${fmt(minPop)} to ${fmt(maxPop)}`;
}

function attachHandleDrag(handle, isMin){
  let dragging = false;
  function onDown(e){
    dragging = true;
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchmove', onMove, {passive:false});
    document.addEventListener('touchend', onUp);
    e.preventDefault();
  }
  function clientX(e){
    if(e.touches && e.touches[0]) return e.touches[0].clientX;
    return e.clientX;
  }
  function onMove(e){
    if(!dragging) return;
    const rect = rangeEl.getBoundingClientRect();
    const x = clientX(e);
    const rel = Math.min(Math.max((x - rect.left)/rect.width, 0), 1);
    const idx = Math.round(rel * (STEPS.length - 1));
    if(isMin){ minIndex = Math.min(idx, maxIndex); } else { maxIndex = Math.max(idx, minIndex); }
    updateSliderUI();
    renderCities();
  }
  function onUp(){
    dragging = false;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('touchend', onUp);
  }
  handle.addEventListener('mousedown', onDown);
  handle.addEventListener('touchstart', onDown, {passive:false});
}
attachHandleDrag(handleMin, true);
attachHandleDrag(handleMax, false);
updateSliderUI();

// Simple CSV parser for the known format
// Simple CSV parser for the known format
function parseCSV(txt) {
  const lines = txt.trim().split(/\r?\n/);
  const headers = lines[0].split(',').map(h => h.trim());
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(',').map(c => c.trim());
    const o = {};
    headers.forEach((h, j) => {
      o[h] = cols[j] || '';
    });
    rows.push(o);
  }
  return rows;
}


async function init() {
  try {
    const [csvRes, svgRes] = await Promise.all([fetch(CSV_URL), fetch(SVG_URL)]);
    const csvTxt = await csvRes.text();
    const svgTxt = await svgRes.text();
    const parsed = parseCSV(csvTxt);

    cities = parsed.map(r => {
      const name = r['City name'];
      const lat = parseFloat(r.lat);
      const lon = parseFloat(r.lng);
      const pop = parseInt(r.population, 10);
      return { name, lat, lon, pop };
    }).filter(c => c.name && isFinite(c.lat) && isFinite(c.lon) && c.pop);

    document.getElementById('mapContainer').innerHTML = svgTxt;
    svgElement = document.querySelector('#mapContainer svg');
    const vb = svgElement.getAttribute('viewBox');
    if (vb) {
      const p = vb.split(/\s+|,/).map(Number).filter(n => !isNaN(n));
      if (p.length === 4) svgViewBox = { x: p[0], y: p[1], width: p[2], height: p[3] };
    } else {
      svgElement.setAttribute('viewBox', '0 0 800 600');
    }
    svgElement.setAttribute('id', 'czMap');

    // Remove inline fills that may conflict (safer sync)
    svgElement.querySelectorAll('path').forEach(p => {
      p.removeAttribute('fill');
    });

    const loader = document.getElementById('mapLoader');
    if (loader) loader.remove();

    // Initial sync to page background
    syncMapFillWithBackground();

    renderCities();
  } catch (e) {
    const loader = document.getElementById('mapLoader');
    if (loader) loader.textContent = "Error: " + e.message;
  }
}

function wrapLabel(name, maxCharsPerLine){
  const words = name.split(/\s+/);
  const lines = [];
  let current = '';
  words.forEach(w=>{
    if(!current.length){ current = w; }
    else if((current + ' ' + w).length <= maxCharsPerLine){
      current += ' ' + w;
    } else {
      lines.push(current);
      current = w;
    }
  });
  if(current) lines.push(current);
  return lines;
}

function localDensityFactor(px, py, points){
  let count = 0;
  const R = 18;
  for(const q of points){
    const dx = q.x - px, dy = q.y - py;
    if(Math.sqrt(dx*dx + dy*dy) < R) count++;
  }
  return Math.min(3, count);
}

function radiusForPopulation(pop){
  const value = Math.log10(Math.max(1, pop));
  const r = (value - 3.5) * 2.2;
  return Math.max(1.2, Math.min(10, r));
}

function rectIntersects(a, b, pad=0){
  return !(a.x2 + pad < b.x1 - pad || a.x1 - pad > b.x2 + pad || a.y2 + pad < b.y1 - pad || a.y1 - pad > b.y2 + pad);
}
function bboxToRect(bbox){
  return { x1: bbox.x, y1: bbox.y, x2: bbox.x + bbox.width, y2: bbox.y + bbox.height };
}

const CANDIDATE_OFFSETS = [
  {dx:0, dy:-8, anchor:'top'},
  {dx:0, dy:8, anchor:'bottom'},
  {dx:14, dy:-10, anchor:'right-top'},
  {dx:14, dy:4, anchor:'right'},
  {dx:14, dy:14, anchor:'right-bottom'},
  {dx:-14, dy:-10, anchor:'left-top'},
  {dx:-14, dy:4, anchor:'left'},
  {dx:-14, dy:14, anchor:'left-bottom'},
  {dx:0, dy:-24, anchor:'top-far'},
  {dx:0, dy:24, anchor:'bottom-far'}
];

function rectInsideViewBox(rect, viewBox, pad = 0) {
  return (
    rect.x1 >= viewBox.x - pad &&
    rect.y1 >= viewBox.y - pad &&
    rect.x2 <= viewBox.x + viewBox.width + pad &&
    rect.y2 <= viewBox.y + viewBox.height + pad
  );
}

function renderCities() {
  if (!svgElement) return;
  let g = svgElement.querySelector('#dotGroup');
  if (!g) {
    g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.id = 'dotGroup';
    svgElement.appendChild(g);
  }
  while (g.firstChild) g.removeChild(g.firstChild);

  const leaderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  leaderGroup.setAttribute('id', 'leaderGroup');
  g.appendChild(leaderGroup);

  const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  labelGroup.setAttribute('id', 'labelGroup');
  g.appendChild(labelGroup);

  const minPop = STEPS[Math.min(minIndex, maxIndex)];
  const maxPop = STEPS[Math.max(minIndex, maxIndex)];
  let filtered = cities.filter(c => c.pop >= minPop && c.pop <= maxPop);

  filtered.sort((a, b) => b.pop - a.pop);

  const positions = filtered.map(c => mapLatLonToSvg(c.lat, c.lon));
  const radii = filtered.map(c => radiusForPopulation(c.pop));

  const dotRects = positions.map((p, i) => {
    const r = radii[i];
    return { x1: p.x - r - 1, y1: p.y - r - 1, x2: p.x + r + 1, y2: p.y + r + 1 };
  });

  const placedRects = [];

  filtered.forEach((city, idx) => {
    const p = positions[idx];
    const r = radii[idx];

    // City dot
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', Math.round(p.x));
    circle.setAttribute('cy', Math.round(p.y));
    circle.setAttribute('r', r);
    circle.setAttribute('fill', 'red');
    circle.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--outline-color').trim() || '#ffffff');
    circle.setAttribute('stroke-width', '0.5');
    g.appendChild(circle);

    // Prepare label text (snap to whole pixels)
    const density = localDensityFactor(p.x, p.y, positions);
    const baseChars = 6;
    const maxCharsPerLine = Math.max(4, baseChars - density);
    const lines = wrapLabel(city.name, maxCharsPerLine);

    let chosen = null;
    let chosenBBox = null;

    // Try candidate offsets
    const offsets = [...CANDIDATE_OFFSETS];
    for (let dist = 20; dist <= 40; dist += 10) {
      offsets.push({ dx: dist, dy: 0 });
      offsets.push({ dx: -dist, dy: 0 });
      offsets.push({ dx: 0, dy: dist });
      offsets.push({ dx: 0, dy: -dist });
    }

    // Try with normal font size, then smaller if needed
    for (let fontSize of [4, 3.5, 3]) {
      for (const off of offsets) {
        const tx = Math.round(p.x + off.dx);
        const ty = Math.round(p.y + off.dy);

        const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tempText.setAttribute('class', 'city-label');
        tempText.setAttribute('x', tx);
        tempText.setAttribute('y', ty);
        tempText.setAttribute('text-anchor', 'middle');
        tempText.setAttribute('font-size', fontSize);

        lines.forEach((line, i) => {
          const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          tspan.setAttribute('x', tx);
          tspan.setAttribute('dy', i === 0 ? '0' : '1.05em');
          tspan.textContent = line;
          tempText.appendChild(tspan);
        });

        labelGroup.appendChild(tempText);
        const bbox = tempText.getBBox();
        const rect = bboxToRect(bbox);
        const PAD = 2;
        const paddedRect = { x1: rect.x1 - PAD, y1: rect.y1 - PAD, x2: rect.x2 + PAD, y2: rect.y2 + PAD };

        let collides = false;
        for (const rct of placedRects) {
          if (rectIntersects(paddedRect, rct, 0)) { collides = true; break; }
        }
        for (let j = 0; j < dotRects.length && !collides; j++) {
          if (rectIntersects(paddedRect, dotRects[j], 0)) { collides = true; break; }
        }
        if (!collides && !rectInsideViewBox(paddedRect, svgViewBox, 0)) {
          collides = true;
        }

        if (!collides) {
          chosen = tempText;
          chosenBBox = paddedRect;
          break;
        } else {
          labelGroup.removeChild(tempText);
        }
      }
      if (chosen) break;
    }

    // Final fallback: force label above dot (snapped)
    if (!chosen) {
      const tx = Math.round(p.x);
      const ty = Math.round(p.y - 10);
      chosen = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      chosen.setAttribute('class', 'city-label');
      chosen.setAttribute('x', tx);
      chosen.setAttribute('y', ty);
      chosen.setAttribute('text-anchor', 'middle');
      chosen.setAttribute('font-size', 3);

      lines.forEach((line, i) => {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttribute('x', tx);
        tspan.setAttribute('dy', i === 0 ? '0' : '1.05em');
        tspan.textContent = line;
        chosen.appendChild(tspan);
      });
      labelGroup.appendChild(chosen);
      chosenBBox = bboxToRect(chosen.getBBox());
    }

    placedRects.push(chosenBBox);

    // Draw leader line
    const lx = Math.max(chosenBBox.x1, Math.min(p.x, chosenBBox.x2));
    const ly = Math.max(chosenBBox.y1, Math.min(p.y, chosenBBox.y2));
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', Math.round(lx));
    line.setAttribute('y1', Math.round(ly));
    line.setAttribute('x2', Math.round(p.x));
    line.setAttribute('y2', Math.round(p.y));
    line.setAttribute('class', 'leader');
    leaderGroup.appendChild(line);
  });
}

init();

/* ---------- Background color & contrast logic ---------- */
const bgPicker = document.getElementById('bgColorPicker');
const colorBtns = document.querySelectorAll('.color-btn');

function parseRgbOrHexToRgb(color) {
  if (color.startsWith('#')) {
    const bigint = parseInt(color.slice(1), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
  }
  const m = color.match(/\d+/g);
  if (!m) return [0,0,0];
  return m.map(Number).slice(0,3);
}
function getLuminance(color) {
  const [r,g,b] = parseRgbOrHexToRgb(color);
  return (0.299*r + 0.587*g + 0.114*b) / 255;
}

function setLabelStrokeForBackground(color) {
  const lum = getLuminance(color);
  if (!svgElement) return;
  svgElement.querySelectorAll('.city-label').forEach(lbl => {
    if (lum > 0.5) {
      // Light background → dark text, no halo
      lbl.removeAttribute('stroke');
      lbl.removeAttribute('stroke-width');
    } else {
      // Dark background → subtle black halo
      lbl.setAttribute('stroke', 'rgba(0,0,0,0.45)');
      lbl.setAttribute('stroke-width', '0.6');
    }
  });
}

function setCssOutlineColor(color) {
  const lum = getLuminance(color);
  const outline = lum > 0.5 ? '#000000' : '#ffffff';
  document.documentElement.style.setProperty('--outline-color', outline);
  setLabelStrokeForBackground(color);
}

function setBackground(color) {
  // Solid background on body and wrap (avoid gradient mismatch)
  document.body.style.background = color;
  document.querySelector('.wrap').style.background = color;

  // Map background (fill all paths and non-transparent rects)
  if (svgElement) {
    svgElement.querySelectorAll('path').forEach(p => p.setAttribute('fill', color));
    svgElement.querySelectorAll('rect').forEach(r => {
      if (!r.hasAttribute('fill') || r.getAttribute('fill') !== 'none') {
        r.setAttribute('fill', color);
      }
    });
  }

  // Update outline/leader color via CSS variable and label stroke
  setCssOutlineColor(color);
}

function syncMapFillWithBackground() {
  const bg = getComputedStyle(document.body).backgroundColor;
  // Normalize wrap to solid color to match body
  const wrap = document.querySelector('.wrap');
  wrap.style.background = bg;

  // Fill SVG background
  if (svgElement) {
    svgElement.querySelectorAll('path').forEach(p => p.setAttribute('fill', bg));
    svgElement.querySelectorAll('rect').forEach(r => {
      if (!r.hasAttribute('fill') || r.getAttribute('fill') !== 'none') {
        r.setAttribute('fill', bg);
      }
    });
  }

  // Set outline color variable and adjust label stroke
  setCssOutlineColor(bg);
}

bgPicker.addEventListener('input', e => {
  setBackground(e.target.value);
});
colorBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const color = btn.getAttribute('data-color');
    bgPicker.value = color;
    setBackground(color);
  });
});
</script>
</body>
</html>
